0. generic assemble array routine ? (a, b, …, c, ‘’, A, B, …C, ‘’, …)
    - base this off of scipy.linalg.block_diag ... or is there
      something there already?

1. Update duf explanation in cla.apply_uf

5. Convert ext, mx, mn in DR_Results to dataframe

6. rddmig needs profiling / updating for very large DMIGs

7. add wtdmig
   - add tests
   - beta in 0.93.6

12. op4: add some c?

15. cla.py:
    DR_Results() … should this be able to init? I think so:
                   DR_Results(drdefs, mission, event)
                   … similar to DR.prepare_results(mission, event)
                   … and/or, what about a DR_Def.prepare_results()
    - actually, replace DR_Event.prepare_results() I think
                   Get rid of Info in DR_Event? Probably can’t because
                   of the uf_reds override.

    Naming convention should be more consistent:
      drdefs vs. Info vs. drminfo
         - Could they all be DR_Def instances??

         - Info can be a DR_Def instance ... but each drminfo is just
           a SimpleNamespace: a "value" in the DR_Def (or Info) dict

    - think about getting rid of DR_Event altogether ... just update
      a new DR_Def with all drdefs/dufs/ulvs's ... will this work?
      - i don't think so

    Update the code to better handle NaNs.
      - got a couple different methods going right now ... ??

    2 write complete test_cla.py
    4 when flagging, but no flags, format is shortened by one char for that column
    5 maybe add option to use only one figure ... that should be default ?
    6 y-axis label written far away in srs3/net_ifatm_0rb_eqsine_all.pdf plot ... why?
    8 Save eqsine to xlsx file


19. Add windowends to srs ?


21. In cb or cla:
    - In mk_net_drms, add use_g_units
    - make routine that returns string for adding data recovery categories for mk_net_drms output:
        """
        @cla.DR_Def.addcat
        def _():
            name = 'net_ifatm'
            ...
        ...
        """
        o   Could accept s/c name for description strings
        o   Or, make this just a function call? … that actually runs it?
            §  Would need defaults and maybe other inputs
            §  Could have it call mk_net_drms internally


23. ? Add option to change time step during simulation
    o   Save parameters in dictionary for each time step?
    o   Or, are the params cheap to recompute?
    Hmm ... would have to decide how to save results (even time steps?)


31. frf_apply_duf – see if needed and consider renaming (psd_apply_duf?)

32. cla:
    - Maybe should have capability to create null (zeros) category
      (with srs’s) … or just make sure zero case is accounted for in
      combination … hmm.

    - Form_extreme
       - Skip some events? (Like static and random, but include total)

34. cb: Teach cbtf to handle 0 frequency case like solveunc.fsolve
    does.

36. cbreorder could take tuple of matrices ...

38. test_ntfl_rbdamping: figure this out:
    pre_eig = True doesn't work ... not sure why at the
    moment (maybe conflict with rb modes setting)

39. DR.add – should check for drms and nondrms … ?
    -  What about an easier way to just proceed without nas
       (if None, more actively make do without it … with
       warning maybe?)

43. Bref – what about a model with mechanisms?
    - let bref not be a mult of 6?

48. add sparse Newmark solver

52. In rdpostop2, matrix names should probably be lower case.

53. Enhance the ‘seconct’ output (include ‘up’, ‘down’? … this is only down (I think)):

   p = op2.rdpostop2(sys_op2 + '.op2')
   seconct = {}
   j = 0
   for ind in (p['seconct'] == -1).nonzero()[0][::2]:
       seconct[p['seconct'][j]] = p['seconct'][j+8:ind][::2]
       j = ind + 2

   {101: array([     91,      92,      93, ..., 5907498, 5907499, 5907500], dtype=int32),
   102: array([1290001, 1290002, 1290003, ..., 1710100, 1710101, 1710102], dtype=int32),
   201: array([2000004, 2005283, 2005319, ..., 5924498, 5924499, 5924500], dtype=int32),
   609: array([7999031, 7999032, 7999033, ..., 9004098, 9004099, 9004100], dtype=int32)}

~ 58. Order of recovery should be maintained from definition order
     o   I think the only change (besides documenting that order is
         used) is to change this from:
            self.Info = {}
     o   To:
            self.Info = OrderedDict()
     o   In DR_Event.__init__

59. For 58 to be really useful, probably need to enhance
    calls to the drfuncs … would want access to other categories.
    Need some good ideas for this.
     o   Pass in the parent DR_Results … ?

     o Update drfunc arg list to enhance functionality:
    - now: drfunc(sol, nas, Vars, se)
    - new, after discussion with BTA:
      drfunc(sol, se_vars, event_data, user_arg) ... or something
      - event_data is a dict with potentially:
         - parent DR_Results
         - name
         - se
         - drmres SimpleNamespace
         - number of cases
         - current case
         - ? freq for psd functions?
         - nas

63. mk_net_drms: output coord system could be input ...
    think of multiple ports

    - Having this internal would help because cglf could be formed
      in proper local coord system

    - actually, cglf is junk anyway isn't it? It would be computing
      based on the structure with the ports ... not the item attached
      to the port

    - but, ifatm and ifltm for the port would be nice ... probably

    - ALSO: have it be able to output "g, rad/sec^2", "g, g/in", and
      "in/sec^2, rad/sec^2"

66. Write a nastran coordinate system plotter
    - use pyNastran instead?

67. Write a nastran node plotter
    - use pyNastran instead?

68. Add extreme histories to cla.DR_Results.form_extreme

69. Find or write a replacement for "mkruns"
    - Britney has something maybe for this ... ?

71. Implement compmat i think

73. Check into subspace iteration logic
    - Bathe K.J. The subspace iteration method – Revisited.
      Comput Struct (2012),
      http://dx.doi.org/10.1016/j.compstruc.2012.06.002

    - https://www-users.cs.umn.edu/~saad/PDF/ys-2014-1.pdf

74. Implement ERA algorithm

``75. Check out coverage for parallel processing
    o   Also, those if’s without an else … ? “Branch” testing.
    - unsuccessful on first attempt ... worth it?

76. Check manifest app

77. Accommodate ulvs, mugf and nothing … via a tag?
    - What about ‘drms’ and ‘nondrms’?
    - idea: instead of 'drms' and 'nondrms', use categories that
      specify which transform is to be used:
       - 'modes' (or 'phi' or 'ulvs' or ?)
       - 'resflex' (or 'g' or 'rf' or 'mugf' or ?)
       - 'none' (or 'other' or 'misc' or 'data' or ?)
    - from discussion with BTA, think about using, for example:
         acce = ltma
         velo = ltmv
         disp = ltmd
         forc = ltmf
       - probably wouldn't need to define a drfunc in this case!

83. rddmig reads upper case names for op2, lower for pch?

84. if licensing is good, update guitools to Qt ... I think (this was
    nearly done i think ... just never finalized it because of license
    (see ~/python/gui/guitools_qt.py))

85. update the numpy docstring output to be current (right now, still
    using v 1.13)

87. Add "addcat" skeleton code generator?
    - goal is to make adding data recovery categories simpler

97. Add the “tf” class somewhere. Maybe ...
      o   After add “pade” …

98. datacursor.DC
    - add highlight_line option? Line would be plotted in a
      specifiable style when clicked (or hovered on?)
      o   Hmm, probably any time an annotation would be drawn
      o   Ability to turn off annotation might then be a desirable
          option

99. Add generator feature and hm features to Newmark-Beta solver

~100. Add the Chapman solver (or similar) with the generator & hm
     features
     - added in version 0.94.6
     - need to add tests for new solver!
     - add as SolveCDF in 0.94.7

101. Add regex to nastran.rdcards …
     ‘DTI     SELOAD’ would be better as ‘DTI\s+SELOAD’

102. Fix up the sparse documentation for wtextseout

103. Add units option to mk_net_drms:
     o   G, rad/sec^2
     o   G, G/in
     o   In/sec^2, rad/sec^2

104. Add 'axis' option fftfilt (and others too probably)
     o make it elegant ... check dsp.exclusive_sgfilter to see if
       that's done well. Numpy must have nice functions for this since
       many of those functions allow it. Share code amongst these
       functions.

~105. Think about refactoring the cd_as_force=True option of SolveUnc
     to its own class ... inheriting from SolveUnc (that way, don’t
     need the non-uniformity of having the cd_as_force option)
       o SolveUncCD? ... And fail when M & K are not diagonal? (nah on
         the fail i think ... just fall back to SolveUnc)
       o Refactoring this seems good for doc purposes
     - done as SolveCDF, v0.94.7

106. Add Henkel-Mar class -- I think. The one in
     python/workworks/henkelmar.py *might* be where to start.

107. Add more tutorials.

~108. Fdepsd Di_test – mention it doesn’t include sigma

~109. I think: get rid of hadamard in SolveUnc doc
     - version 0.94.9

110. Consider refactoring the generator solvers by using “yield from”
     (can code be reused?)

111. Consider refactoring large modules into small files
     o   Approach used in scipy:
         - make ode, cla, ... packages ... just like nastran is now
         - in the ode/__init__.py, imports could be, for example:
              from .solveunc import *
              from .solveexp2 import *

112. Can some things (ode solvers?) be sped up by numba?

~113. Move "finddups" from ode to locate (and rename it to
     'find_duplicates')
     - version 0.94.9
